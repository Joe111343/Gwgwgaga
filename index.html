<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>多人 17 關節骨架 + 麥克風 P2P</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
<style>
body{ margin:0; background:#111; color:#fff; font-family:sans-serif; }
#canvas{ width:100vw; height:100vh; display:block; background:#000; position:absolute; top:0; left:0; z-index:1;}
#video{ display:none; }
#controls{ position:fixed; top:10px; left:10px; background:rgba(0,0,0,0.6); padding:10px; border-radius:8px; z-index:2;}
input, button{ margin:4px;}
</style>
</head>
<body>
<div id="controls">
  <div>你的ID: <span id="myId">...</span></div>
  <input type="text" id="peerId" placeholder="輸入對方ID">
  <button id="connectBtn">連線</button>
</div>
<canvas id="canvas"></canvas>
<video id="video" autoplay playsinline></video>

<script>
(async()=>{
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const myIdSpan = document.getElementById('myId');
  const connectBtn = document.getElementById('connectBtn');
  const peerInput = document.getElementById('peerId');

  // 初始化攝影機 + 麥克風
  const stream = await navigator.mediaDevices.getUserMedia({video:{width:720,height:540}, audio:true});
  video.srcObject = stream;
  await new Promise(r=>video.onloadedmetadata=r);
  video.play();
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;

  // MoveNet MULTIPOSE
  const detector = await poseDetection.createDetector(
    poseDetection.SupportedModels.MoveNet,
    { modelType: poseDetection.movenet.modelType.MULTIPOSE_LIGHTNING }
  );

  // 17 關節
  const SKELETON = [[0,5],[0,6],[5,6],[5,7],[7,9],[6,8],[8,10],[11,12],[5,11],[6,12],[11,13],[13,15],[12,14],[14,16],[1,0],[2,0],[1,3],[2,4]];
  const COLORS = ['#06d6a0','#118ab2','#ef476f','#ffd166','#a78bfa','#ffa8a8','#8ecae6','#fb8500'];

  function drawPersons(persons){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    for(let i=0;i<persons.length;i++){
      ctx.strokeStyle=COLORS[i%COLORS.length]; ctx.lineWidth=3;
      for(const [a,b] of SKELETON){
        const p1=persons[i][a],p2=persons[i][b];
        if(!p1||!p2) continue;
        if(p1.score<0.35||p2.score<0.35) continue;
        ctx.beginPath();
        ctx.moveTo(p1.x,p1.y);
        ctx.lineTo(p2.x,p2.y);
        ctx.stroke();
      }
      for(const k of persons[i]){
        if(k.score<0.35) continue;
        ctx.fillStyle=COLORS[i%COLORS.length];
        ctx.beginPath();
        ctx.arc(k.x,k.y,5,0,Math.PI*2);
        ctx.fill();
      }
    }
  }

  // 短 ID 產生
  function shortId(){ return Math.floor(Math.random()*9000)+1000+''; }
  const myPeerId = shortId();

  // PeerJS 初始化
  const peer = new Peer(myPeerId);
  let conn=null;

  peer.on('open', id=>{
    console.log('Peer 初始化完成 ID:',id);
    myIdSpan.textContent=id;
  });
  peer.on('error', err=>{
    console.error('PeerJS 錯誤:', err);
    myIdSpan.textContent='初始化失敗';
  });

  peer.on('connection', c=>{
    conn=c;
    conn.on('data', data=>{ drawPersons(data); });
  });

  peer.on('call', call=>{
    call.answer(stream);
    call.on('stream', remoteStream=>{
      let audio=document.createElement('audio');
      audio.srcObject=remoteStream;
      audio.autoplay=true; audio.play();
    });
  });

  connectBtn.onclick=()=>{
    const target = peerInput.value.trim();
    if(!target) return alert('請輸入對方ID');
    conn = peer.connect(target);
    conn.on('open', ()=>{
      console.log('已連線到',target);
      const call = peer.call(target,stream);
      call.on('stream', remoteStream=>{
        let audio=document.createElement('audio');
        audio.srcObject=remoteStream;
        audio.autoplay=true; audio.play();
      });
    });
    conn.on('data', data=>{ drawPersons(data); });
  };

  // 主迴圈
  async function loop(){
    const poses = await detector.estimatePoses(video);
    const persons = poses.map(p=>p.keypoints.map(k=>({x:k.x,y:k.y,score:k.score})));
    drawPersons(persons);
    if(conn && conn.open) try{ conn.send(persons); }catch(e){console.log(e);}
    requestAnimationFrame(loop);
  }
  loop();

})();
</script>
</body>
</html>
