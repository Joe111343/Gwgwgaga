<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>多人骨架 P2P + 麥克風（data channel 傳骨架）</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
<style>
body{margin:0;background:#111;color:#fff;font-family:sans-serif;}
#canvas{width:100vw;height:100vh;display:block;background:#111;position:absolute;top:0;left:0;z-index:1;}
#controls{position:fixed;top:10px;left:10px;background:rgba(0,0,0,0.6);padding:10px;border-radius:8px;z-index:2;}
input,button{margin:4px;}
</style>
</head>
<body>
<div id="controls">
  <div>你的ID: <span id="myId">...</span></div>
  <input type="text" id="peerId" placeholder="輸入對方ID">
  <button id="connectBtn">連線</button>
</div>
<canvas id="canvas"></canvas>
<video id="video" autoplay playsinline style="display:none;"></video>

<script>
(async()=>{
// ===== DOM & Canvas =====
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;

const myIdSpan=document.getElementById('myId');
const peerInput=document.getElementById('peerId');
const connectBtn=document.getElementById('connectBtn');

// ===== 初始化攝影機（僅拿音訊） =====
let stream;
try{
  stream=await navigator.mediaDevices.getUserMedia({audio:true,video:false});
}catch(e){alert('無法取得麥克風'); console.error(e); return;}

// ===== 初始化 MoveNet 偵測器 =====
await tf.setBackend('webgl'); await tf.ready();
const detector=await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet,{modelType:poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING});

// ===== 17關節骨架 =====
const SKELETON=[[0,1],[0,2],[1,3],[2,4],[0,5],[0,6],[5,7],[7,9],[6,8],[8,10],[5,11],[6,12],[11,13],[13,15],[12,14],[14,16],[11,12]];
const COLORS=['#06d6a0','#118ab2','#ef476f','#ffd166','#a78bfa','#ffa8a8','#8ecae6','#fb8500'];

// ===== P2P 設定 =====
function shortId(){return Math.floor(Math.random()*9000)+1000+'';}
const myPeerId=shortId();
const peer=new Peer(myPeerId);
let connections=[];
let remotePersons=[];

peer.on('open',id=>{myIdSpan.textContent=id;});
peer.on('connection',c=>{
  connections.push(c);
  c.on('data',data=>{
    try{ remotePersons=JSON.parse(data); }catch(e){console.error('解析遠端資料錯誤',e);}
  });
  c.on('close',()=>connections.splice(connections.indexOf(c),1));
});
peer.on('call',call=>{
  call.answer(stream);
  call.on('stream',remoteStream=>{
    const audio=document.createElement('audio');
    audio.srcObject=remoteStream; audio.autoplay=true; audio.play();
  });
});

// 連線按鈕
connectBtn.onclick=()=>{
  const target=peerInput.value.trim();
  if(!target) return alert('請輸入對方ID');
  const c=peer.connect(target);
  connections.push(c);
  c.on('open',()=>{
    const call=peer.call(target,stream);
    call.on('stream',remoteStream=>{
      const audio=document.createElement('audio');
      audio.srcObject=remoteStream; audio.autoplay=true; audio.play();
    });
  });
  c.on('data',data=>{
    try{ remotePersons=JSON.parse(data); }catch(e){console.error(e);}
  });
  c.on('close',()=>connections.splice(connections.indexOf(c),1));
};

// ===== 繪製骨架 =====
function drawPersons(persons){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let i=0;i<persons.length;i++){
    ctx.strokeStyle=COLORS[i%COLORS.length];
    ctx.lineWidth=3;
    const person=persons[i];
    for(const [a,b] of SKELETON){
      const p1=person[a],p2=person[b]; if(!p1||!p2) continue;
      ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
    }
    for(const k of person){
      ctx.beginPath(); ctx.arc(k.x,k.y,5,0,Math.PI*2);
      ctx.fillStyle=COLORS[i%COLORS.length]; ctx.fill();
    }
  }
}

// ===== 主迴圈 =====
let localPerson=[];
async function loop(){
  // 偵測骨架
  const poses=await detector.estimatePoses(document.getElementById('video'));
  localPerson=poses.length?poses[0].keypoints.map(k=>({x:k.x*2,y:k.y*2,score:k.score})):Array(17).fill({x:Math.random()*canvas.width,y:Math.random()*canvas.height,score:0.5});
  
  // 發送資料給遠端
  const dataStr=JSON.stringify(localPerson);
  connections.forEach(c=>{if(c.open)try{c.send(dataStr);}catch(e){}});
  
  // 畫本地 + 遠端
  drawPersons([localPerson,...remotePersons]);
  
  requestAnimationFrame(loop);
}
loop();

})();
</script>
</body>
</html>
