<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>P2P骨架碰撞完整版</title>
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
<style>
body{margin:0;background:#000;color:#fff;overflow:hidden;font-family:system-ui,sans-serif;}
#controls{position:fixed;top:12px;left:12px;z-index:10;background:#000;padding:10px 12px;border-radius:8px;color:#fff;}
button,input{margin-top:4px;}
#canvas{display:block;background:#fff;}
</style>
</head>
<body>
<div id="controls">
  <div>你的ID: <span id="myId">...</span></div>
  <input type="text" id="peerId" placeholder="輸入對方ID">
  <button id="connectBtn">連線</button><br>
  <button id="startBtn">啟動攝像頭</button>
</div>
<canvas id="canvas"></canvas>
<video id="video" autoplay playsinline style="display:none;"></video>

<script>
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;

const startBtn=document.getElementById('startBtn');
const connectBtn=document.getElementById('connectBtn');
const myIdSpan=document.getElementById('myId');
const peerIdInput=document.getElementById('peerId');

let stream, peer, connections=[], localPose=null, remotePoses={};

// 產生短 ID
function shortId(){return Math.floor(Math.random()*9000)+1000+'';}

// 計算圓形碰撞
function circleCollide(c1,c2){return Math.hypot(c1.x-c2.x, c1.y-c2.y)<(c1.r+c2.r);}

// 取得關節碰撞體
function getJointColliders(kps,scale=1,radius=15){
  if(!kps) return [];
  return kps.map(kp=>({x:kp.x*scale, y:kp.y*scale, r:radius*scale}));
}

// 取得連線碰撞矩形
function getLineColliders(kps,scale=1,width=10){
  if(!kps) return [];
  const links=[[0,5],[0,6],[5,6],[5,7],[7,9],[6,8],[8,10],[5,11],[6,12],[11,12],[11,13],[12,14],[13,15],[14,16]];
  let rects=[];
  links.forEach(([i,j])=>{
    const a=kps[i],b=kps[j];
    if(a?.score>.4 && b?.score>.4){
      const dx=b.x-a.x, dy=b.y-a.y, len=Math.hypot(dx,dy);
      const cx=(a.x+b.x)/2, cy=(a.y+b.y)/2;
      const angle=Math.atan2(dy,dx);
      rects.push({x:cx*scale, y:cy*scale, w:len*scale, h:width*scale, angle:angle});
    }
  });
  return rects;
}

// 檢查碰撞
function checkCollision(localKps,remoteKps,scale=1){
  const lj=getJointColliders(localKps,scale);
  const lLines=getLineColliders(localKps,scale);
  const rj=getJointColliders(remoteKps,scale);
  const rLines=getLineColliders(remoteKps,scale);

  // 關節碰撞
  for(const l of lj) for(const r of rj){if(circleCollide(l,r)) return true;}
  // 線碰撞 (簡單圓形近似)
  for(const l of lLines) for(const r of rLines){
    if(Math.hypot(l.x-r.x,l.y-r.y)<(l.h/2 + r.h/2)) return true;
  }
  return false;
}

// 繪製骨架
function drawPose(kps,color='#ff0000',scale=1){
  if(!kps) return;
  const J={head:0,lShoulder:5,rShoulder:6,lElbow:7,rElbow:8,lWrist:9,rWrist:10,lHip:11,rHip:12,lKnee:13,rKnee:14,lAnkle:15,rAnkle:16};
  const links=[[0,5],[0,6],[5,6],[5,7],[7,9],[6,8],[8,10],[5,11],[6,12],[11,12],[11,13],[12,14],[13,15],[14,16]];
  links.forEach(([i,j])=>{
    const a=kps[i],b=kps[j];
    if(a?.score>.4 && b?.score>.4){
      ctx.strokeStyle=color; ctx.lineWidth=3*scale;
      ctx.beginPath(); ctx.moveTo(a.x*scale,a.y*scale); ctx.lineTo(b.x*scale,b.y*scale); ctx.stroke();
    }
  });
  kps.forEach(kp=>{if(kp?.score>.4){ctx.beginPath();ctx.arc(kp.x*scale,kp.y*scale,5*scale,0,Math.PI*2);ctx.fillStyle=color;ctx.fill();}});
}

// 渲染循環
function renderLoop(){
  ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const scaleX=canvas.width/640; const scaleY=canvas.height/480; const scale=Math.min(scaleX,scaleY);
  if(localPose){
    for(const pid in remotePoses){
      if(checkCollision(localPose,remotePoses[pid],scale)){
        console.log('碰撞發生，阻止移動');
      }
    }
    drawPose(localPose,'#ff0000',scale);
  }
  for(const pid in remotePoses) drawPose(remotePoses[pid],'#0000ff',scale);
  requestAnimationFrame(renderLoop);
}

// 初始化 Pose
async function initPose(){
  await tf.setBackend('webgl'); await tf.ready();
  const detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet,{ modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING });
  
  async function poseLoop(){
    if(stream){
      const poses = await detector.estimatePoses(document.getElementById('video'));
      if(poses.length) localPose=poses[0].keypoints;
      const dataStr=JSON.stringify(localPose);
      connections.forEach(c=>c.send(dataStr));
    }
    requestAnimationFrame(poseLoop);
  }
  poseLoop();
}

// 按鈕事件
startBtn.onclick=async()=>{
  try{
    stream=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480},audio:true});
    document.getElementById('video').srcObject=stream;
    await document.getElementById('video').play();

    const myPeerId=shortId();
    peer=new Peer(myPeerId);
    myIdSpan.textContent=myPeerId;

    peer.on('connection',c=>{
      connections.push(c);
      c.on('data',data=>{try{remotePoses[c.peer]=JSON.parse(data);}catch(e){}});
      c.on('close',()=>{delete remotePoses[c.peer]; connections.splice(connections.indexOf(c),1);});
    });

    peer.on('call',call=>{
      call.answer(stream);
      call.on('stream',remoteStream=>{
        const audio=document.createElement('audio');
        audio.srcObject=remoteStream; audio.autoplay=true; audio.play();
      });
    });

    initPose();
    renderLoop();
    startBtn.disabled=true;
  }catch(e){alert('無法啟動攝像頭或麥克風'); console.error(e);}
};

connectBtn.onclick=()=>{
  const targetId=peerIdInput.value.trim();
  if(!targetId || !peer) return alert('輸入對方ID');
  const conn=peer.connect(targetId);
  connections.push(conn);
  conn.on('data',data=>{try{remotePoses[conn.peer]=JSON.parse(data);}catch(e){}});
  conn.on('open',()=>{peer.call(targetId,stream);});
  conn.on('close',()=>{delete remotePoses[conn.peer]; connections.splice(connections.indexOf(conn),1);});
};
</script>
</body>
</html>
