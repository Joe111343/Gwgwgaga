<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>俯瞰第三人稱 2D 射擊遊戲</title>
  <style>
    html, body {
      margin:0; padding:0; overflow:hidden; background:#111;
      font-family: sans-serif;
      user-select: none;
    }
    canvas {
      background: #222;
      display: block;
      margin: 0 auto;
      cursor: crosshair;
    }
    #ui {
      position: fixed;
      top: 10px; left: 10px;
      color: white;
      font-weight: bold;
      font-size: 18px;
      z-index: 10;
    }
    #startScreen {
      position: fixed;
      top:0; left:0; width:100%; height:100%;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 20;
    }
    button {
      margin: 5px;
      padding: 8px 15px;
      font-size: 16px;
      cursor: pointer;
    }
    input {
      font-size: 16px;
      padding: 5px;
      width: 250px;
      margin: 5px 0;
      text-align: center;
    }
  </style>
</head>
<body>
<div id="startScreen">
  <h1>多人 P2P 俯瞰 2D 射擊遊戲</h1>
  <input id="roomIdInput" placeholder="輸入房間 ID（隨便取）" />
  <button id="createBtn">建立房間</button>
  <button id="joinBtn">加入房間</button>
  <p>請用同一房間 ID 讓多人連線互動</p>
</div>

<div id="ui">
  HP: <span id="hp">100</span> | 玩家數: <span id="playerCount">1</span>
</div>
<canvas id="gameCanvas" width="900" height="600"></canvas>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const hpSpan = document.getElementById("hp");
  const playerCountSpan = document.getElementById("playerCount");
  const startScreen = document.getElementById("startScreen");
  const createBtn = document.getElementById("createBtn");
  const joinBtn = document.getElementById("joinBtn");
  const roomIdInput = document.getElementById("roomIdInput");

  const MAP_WIDTH = 2000;
  const MAP_HEIGHT = 1500;

  // 玩家資料
  const localId = crypto.randomUUID();
  const players = {};
  let bullets = [];
  let obstacles = [];
  let enemies = [];

  // 按鍵與滑鼠狀態
  const keys = {};
  let mousePos = {x: canvas.width / 2, y: canvas.height / 2};
  let mouseDown = false;

  // 本地玩家物件
  const player = {
    id: localId,
    x: MAP_WIDTH / 2,
    y: MAP_HEIGHT / 2,
    angle: 0,
    speed: 4,
    hp: 100,
    color: randomColor(),
  };
  players[localId] = player;

  // WebRTC 連線相關
  let peerConnection = null;
  let dataChannel = null;
  let isHost = false;
  let roomId = null;

  // ICE 伺服器
  const iceConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

  // 障礙物產生
  function generateObstacles() {
    obstacles = [];
    for(let i=0; i<30; i++) {
      obstacles.push({
        x: Math.random() * (MAP_WIDTH - 80) + 40,
        y: Math.random() * (MAP_HEIGHT - 80) + 40,
        w: 60,
        h: 60,
      });
    }
  }

  // 敵人產生（簡易示範，不動的紅色圓）
  function generateEnemies() {
    enemies = [];
    for(let i=0; i<8; i++) {
      enemies.push({
        id: 'enemy_' + i,
        x: Math.random() * (MAP_WIDTH - 60) + 30,
        y: Math.random() * (MAP_HEIGHT - 60) + 30,
        radius: 20,
        hp: 30,
      });
    }
  }

  // 隨機顏色
  function randomColor() {
    return '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
  }

  // 判斷點是否在矩形裡
  function pointInRect(px, py, rect) {
    return px > rect.x && px < rect.x + rect.w && py > rect.y && py < rect.y + rect.h;
  }

  // 碰撞檢查
  function collides(x, y) {
    for(const ob of obstacles) {
      if(pointInRect(x, y, ob)) return true;
    }
    return false;
  }

  // 計算距離
  function dist(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
  }

  // 事件監聽
  window.addEventListener("keydown", e => { keys[e.key.toLowerCase()] = true; });
  window.addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });
  canvas.addEventListener("mousemove", e => {
    mousePos = { x: e.offsetX, y: e.offsetY };
  });
  canvas.addEventListener("mousedown", e => {
    mouseDown = true;
    shootBullet();
  });
  canvas.addEventListener("mouseup", e => {
    mouseDown = false;
  });

  // 射擊
  function shootBullet() {
    if(player.hp <= 0) return;
    bullets.push({
      id: localId,
      x: player.x + Math.cos(player.angle) * 20,
      y: player.y + Math.sin(player.angle) * 20,
      angle: player.angle,
      speed: 10,
      radius: 6,
    });
    sendData({
      type: "shoot",
      x: player.x + Math.cos(player.angle) * 20,
      y: player.y + Math.sin(player.angle) * 20,
      angle: player.angle,
    });
  }

  // 更新本地玩家
  function updatePlayer() {
    if(player.hp <= 0) return;
    // 玩家角度對準滑鼠相對畫面中心
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const dx = mousePos.x - centerX;
    const dy = mousePos.y - centerY;
    player.angle = Math.atan2(dy, dx);

    let nextX = player.x;
    let nextY = player.y;

    if(keys['w']) {
      nextX += Math.cos(player.angle) * player.speed;
      nextY += Math.sin(player.angle) * player.speed;
    }
    if(keys['s']) {
      nextX -= Math.cos(player.angle) * player.speed;
      nextY -= Math.sin(player.angle) * player.speed;
    }
    if(keys['a']) {
      // 左移 (垂直於面向角度)
      nextX += Math.cos(player.angle - Math.PI/2) * player.speed;
      nextY += Math.sin(player.angle - Math.PI/2) * player.speed;
    }
    if(keys['d']) {
      // 右移
      nextX += Math.cos(player.angle + Math.PI/2) * player.speed;
      nextY += Math.sin(player.angle + Math.PI/2) * player.speed;
    }

    if(!collides(nextX, nextY)) {
      // 邊界限制
      player.x = Math.min(Math.max(nextX, 0), MAP_WIDTH);
      player.y = Math.min(Math.max(nextY, 0), MAP_HEIGHT);
    }
  }

  // 更新子彈
  function updateBullets() {
    bullets = bullets.filter(b => {
      b.x += Math.cos(b.angle) * b.speed;
      b.y += Math.sin(b.angle) * b.speed;
      // 子彈超出地圖範圍就刪除
      if(b.x < 0 || b.x > MAP_WIDTH || b.y < 0 || b.y > MAP_HEIGHT) return false;

      // 檢查是否打到敵人
      for(const en of enemies) {
        if(en.hp > 0 && dist(b, en) < en.radius) {
          en.hp -= 10;
          sendData({type:"enemyHit", id: en.id, hp: en.hp});
          return false;
        }
      }

      return true;
    });
  }

  // 繪製自繪角色（有頭身手腳）
  function drawPlayer(p, isLocal) {
    const drawX = canvas.width / 2 + p.x - player.x;
    const drawY = canvas.height / 2 + p.y - player.y;

    ctx.save();
    ctx.translate(drawX, drawY);
    ctx.rotate(p.angle);
    ctx.fillStyle = p.color;

    // 身體
    ctx.fillRect(-12, -20, 24, 40);

    // 頭
    ctx.beginPath();
    ctx.arc(0, -30, 14, 0, Math.PI*2);
    ctx.fill();

    // 左手
    ctx.beginPath();
    ctx.moveTo(-12, -10);
    ctx.lineTo(-30, 0);
    ctx.lineTo(-24, 8);
    ctx.closePath();
    ctx.fill();

    // 右手（槍）
    ctx.beginPath();
    ctx.moveTo(12, -10);
    ctx.lineTo(35, 0);
    ctx.lineTo(28, 8);
    ctx.closePath();
    ctx.fill();

    // 左腳
    ctx.beginPath();
    ctx.moveTo(-8, 20);
    ctx.lineTo(-20, 40);
    ctx.lineTo(-10, 40);
    ctx.closePath();
    ctx.fill();

// 右腳
ctx.beginPath();
ctx.moveTo(8, 20);
ctx.lineTo(20, 40);
ctx.lineTo(10, 40);
ctx.closePath();
ctx.fill();

// 繪製名字（本地玩家顯示"你"）
ctx.fillStyle = "white";
ctx.font = "16px sans-serif";
ctx.textAlign = "center";
ctx.fillText(isLocal ? "你" : p.id.slice(0,5), 0, -45);

ctx.restore();

}

// 繪製障礙物 function drawObstacles() { ctx.fillStyle = "#555"; for(const ob of obstacles) { const drawX = canvas.width / 2 + ob.x - player.x; const drawY = canvas.height / 2 + ob.y - player.y; ctx.fillRect(drawX, drawY, ob.w, ob.h); } }

// 繪製敵人 function drawEnemies() { for(const en of enemies) { if(en.hp <= 0) continue; const drawX = canvas.width / 2 + en.x - player.x; const drawY = canvas.height / 2 + en.y - player.y; ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(drawX, drawY, en.radius, 0, Math.PI*2); ctx.fill();

// 血條
  ctx.fillStyle = 'black';
  ctx.fillRect(drawX - 20, drawY - 30, 40, 6);
  ctx.fillStyle = 'limegreen';
  ctx.fillRect(drawX - 20, drawY - 30, 40 * Math.max(0, en.hp/30), 6);
}

}

// 繪製子彈 function drawBullets() { ctx.fillStyle = 'yellow'; for(const b of bullets) { const drawX = canvas.width / 2 + b.x - player.x; const drawY = canvas.height / 2 + b.y - player.y; ctx.beginPath(); ctx.arc(drawX, drawY, 6, 0, Math.PI*2); ctx.fill(); } }

// 遊戲主迴圈 function gameLoop() { updatePlayer(); updateBullets();

ctx.clearRect(0, 0, canvas.width, canvas.height);
drawObstacles();
drawEnemies();
drawBullets();

// 繪製所有玩家
let countAlive = 0;
for(const pid in players) {
  const p = players[pid];
  if(p.hp > 0) countAlive++;
  drawPlayer(p, pid === localId);
}

// 更新UI
hpSpan.textContent = Math.floor(player.hp);
playerCountSpan.textContent = countAlive;

if(player.hp <= 0) {
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = 'red';
  ctx.font = '48px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('你死了！請重新整理頁面', canvas.width/2, canvas.height/2);
  return; // 停止遊戲迴圈
}

requestAnimationFrame(gameLoop);

}

// WebRTC 相關

async function setupConnection() { peerConnection = new RTCPeerConnection(iceConfig);

if(isHost) {
  dataChannel = peerConnection.createDataChannel("game");
  setupDataChannelEvents();
  const offer = await peerConnection.createOffer();
  await peerConnection.setLocalDescription(offer);
  await signalingSend({ type: "offer", offer: offer });
} else {
  peerConnection.ondatachannel = e => {
    dataChannel = e.channel;
    setupDataChannelEvents();
  };
}

peerConnection.onicecandidate = e => {
  if(e.candidate) signalingSend({ type: "candidate", candidate: e.candidate });
};

signalingListen();

}

// 簡易訊號交換（示範用，請自行替換為實際訊號服務或Firebase等） // 這裡用 localStorage 作訊號交換示範（不適合真實多人，只能同一瀏覽器分頁測試）

function signalingSend(msg) { const key = webrtc-${roomId}; const data = { from: localId, msg }; localStorage.setItem(key, JSON.stringify(data)); }

window.addEventListener('storage', e => { if(!e.key || !e.newValue) return; if(e.key !== webrtc-${roomId}) return; const data = JSON.parse(e.newValue); if(data.from === localId) return; // 忽略自己訊息 handleSignalingMessage(data.msg); });

async function signalingListen() { // 讀取現有訊息不處理（此簡易demo只用storage事件） }

async function handleSignalingMessage(msg) { if(!peerConnection) return; if(msg.type === "offer" && !isHost) { await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.offer)); const answer = await peerConnection.createAnswer(); await peerConnection.setLocalDescription(answer); signalingSend({ type: "answer", answer }); } else if(msg.type === "answer" && isHost) { await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.answer)); } else if(msg.type === "candidate") { try { await peerConnection.addIceCandidate(msg.candidate); } catch(e) { console.warn('ICE candidate error:', e); } } }

function setupDataChannelEvents() { dataChannel.onopen = () => { console.log("DataChannel opened!"); startScreen.style.display = "none"; generateObstacles(); generateEnemies(); gameLoop(); sendPlayerData(); // 立即發送一次位置 }; dataChannel.onmessage = e => { try { const msg = JSON.parse(e.data); handleDataMessage(msg); } catch(e) { console.error("解析訊息錯誤:", e); } }; dataChannel.onclose = () => { alert("連線中斷！"); location.reload(); }; }

// 傳送本地玩家狀態 function sendPlayerData() { if(dataChannel && dataChannel.readyState === "open") { dataChannel.send(JSON.stringify({ type: "update", id: localId, x: player.x, y: player.y, angle: player.angle, hp: player.hp, color: player.color, })); } }

// 傳送資料簡便包裝 function sendData(msg) { if(dataChannel && dataChannel.readyState === "open") { dataChannel.send(JSON.stringify(msg)); } }

// 處理接收的資料訊息 function handleDataMessage(msg) { if(msg.type === "update") { if(!players[msg.id]) { players[msg.id] = { id: msg.id, x: msg.x, y: msg.y, angle: msg.angle, hp: msg.hp, color: msg.color, }; } else { players[msg.id].x = msg.x; players[msg.id].y = msg.y; players[msg.id].angle = msg.angle; players[msg.id].hp = msg.hp; } } else if(msg.type === "shoot") { bullets.push({ id: msg.id, x: msg.x, y: msg.y, angle: msg.angle, speed: 10, radius: 6, }); } else if(msg.type === "enemyHit") { const en = enemies.find(e => e.id === msg.id); if(en) { en.hp = msg.hp; } } }

// 連續更新與傳送本地玩家資料 setInterval(() => { sendPlayerData(); }, 50);

// 建立房間事件 createBtn.onclick = async () => { roomId = roomIdInput.value.trim(); if(!roomId) { alert("請輸入房間ID！"); return; } isHost = true; await setupConnection(); };

// 加入房間事件 joinBtn.onclick = async () => { roomId = roomIdInput.value.trim(); if(!roomId) { alert("請輸入房間ID！"); return; } isHost = false; await setupConnection(); };

})(); </script>

</body>
</html>